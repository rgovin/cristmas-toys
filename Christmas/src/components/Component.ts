import { Callback, Data, Parent, Template } from '../types/types';import { templateEngine } from './Services/templateEngine';class Observer {  private effects: Function[];  constructor() {    this.effects = [];  }  add(cb: Function) {    this.effects.push(cb);  }  remove(cb: Function) {    const effectIndex = this.effects.indexOf(cb);    if (effectIndex !== -1)      this.effects.splice(effectIndex, 1);  }  run<T>(param?: T){    if (this.effects.length) {      this.effects.forEach((effect) => effect(param));    }  }}interface Children{  selector: string;  components: Component[];}export class Component{  private template: Template;  public renderEffects: Observer;  public modelEffects: Observer;  public modelCache: Data;  private children: Children[];  private parent: HTMLElement | null;  constructor(template: Template, model = {}) {    this.template = template;    this.renderEffects = new Observer();    this.modelEffects = new Observer();    this.modelCache = model;    this.children = [];    this.parent = null;    this.updateTemplate();  }  get model(){    return this.modelCache;  }  set model(value){    this.modelCache = value;    this.updateTemplate();    this.modelEffects.run(value);  }  updateTemplate(){    this.template = templateEngine(this.template as string, this.model);  }  insert(selector: string, components: Component[]){    this.children.push({ selector, components });  }  changeTemplate(template: Template): Template{    this.template = template;    return this.template;  }  clear(selector: string){    if (this.parent){      const container = this.parent.querySelector(selector);      if (container) container.innerHTML = '';    }  }  renderChildren(parent: HTMLElement){    if (this.children.length){      this.children.forEach(({ selector, components }) => {        const inner = parent.querySelector(selector) as HTMLElement;        components.forEach((component) => {          component.appendTo(inner);        });      });    }  }  appendTo(parent: HTMLElement){    if (this.template) {      parent.insertAdjacentHTML('beforeend', this.template);      this.renderChildren(parent);      this.renderEffects.run<HTMLElement>(parent);      this.parent = parent;    }  }  renderTo(parent: HTMLElement){    if (this.template) {      parent.innerHTML = templateEngine(this.template, this.model);      this.renderChildren(parent);      this.renderEffects.run<HTMLElement>(parent);      this.parent = parent;    }  }  render(parent: HTMLElement): boolean {    if (this.template) {      parent.innerHTML = this.getTemplateWithModel();      this.renderEffects.run<HTMLElement>(parent);      this.parent = parent;      return true;    }    return false;  }  view(): Template{    return this.template;  }  getTemplateWithModel(){    return templateEngine(this.template as string, this.model);  }}